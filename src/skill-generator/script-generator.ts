/**
 * Generate executable, parameterized scripts from procedural patterns
 */

import type { Procedure, ProceduralStep } from '../stages/syntactic.ts';
import type { Skill } from '../types/skill.ts';

/**
 * Extract common base path from file paths
 */
function extractBasePath(paths: string[]): string | null {
  if (paths.length === 0) return null;

  const parts = paths[0]!.split('/');
  let commonPath = '';

  for (let i = 0; i < parts.length - 1; i++) {
    const testPath = parts.slice(0, i + 1).join('/');
    if (paths.every(p => p.startsWith(testPath + '/'))) {
      commonPath = testPath;
    } else {
      break;
    }
  }

  return commonPath || null;
}

/**
 * Generate a parameterized Bun script that replays the procedure
 */
export function generateExecutableScript(
  skill: Skill,
  procedure: Procedure
): string {
  const lines: string[] = [
    '#!/usr/bin/env bun',
    '/**',
    ` * ${skill.name} - Auto-generated skill script`,
    ` * Generated by Engram from pattern: ${skill.sourcePatternId}`,
    ' *',
    ` * ${skill.description}`,
    ' */',
    '',
    'import { $ } from "bun";',
    '',
    '// Parse arguments',
    'const args = process.argv.slice(2);',
    'const targetDir = args[0] || process.cwd();',
    '',
    'console.log(`Running ${skill.name} in ${targetDir}`);',
    '',
  ];

  // Generate step functions
  for (const step of procedure.steps) {
    lines.push(generateParameterizedStepFunction(step));
    lines.push('');
  }

  // Generate main execution
  lines.push('async function main() {');
  lines.push('  try {');

  for (const step of procedure.steps) {
    lines.push(`    console.log("Step ${step.order}: ${step.action.replace(/"/g, '\\"')}");`);
    lines.push(`    await step${step.order}();`);
  }

  lines.push('');
  lines.push('    console.log("\\nCompleted successfully");');
  lines.push('  } catch (error) {');
  lines.push('    console.error("Failed:", error);');
  lines.push('    process.exit(1);');
  lines.push('  }');
  lines.push('}');
  lines.push('');
  lines.push('main();');

  return lines.join('\n');
}

function generateParameterizedStepFunction(step: ProceduralStep): string {
  const lines: string[] = [];

  lines.push(`async function step${step.order}() {`);

  switch (step.tool) {
    case 'Bash':
      lines.push(generateParameterizedBashStep(step));
      break;
    case 'Read':
      lines.push(generateParameterizedReadStep(step));
      break;
    case 'Write':
      lines.push(generateParameterizedWriteStep(step));
      break;
    case 'Edit':
      lines.push(generateParameterizedEditStep(step));
      break;
    case 'Glob':
      lines.push(generateParameterizedGlobStep(step));
      break;
    case 'Grep':
      lines.push(generateParameterizedGrepStep(step));
      break;
    default:
      lines.push(`  // TODO: Implement ${step.tool} step`);
      lines.push(`  console.log("Would run ${step.tool}");`);
  }

  lines.push('}');

  return lines.join('\n');
}

function generateParameterizedBashStep(step: ProceduralStep): string {
  const command = step.parameters.command as string || 'echo "no command"';

  // Replace hardcoded paths with targetDir
  const parameterized = command
    .replace(/\/Users\/[^/]+\/[^\s"']+/g, '${targetDir}')
    .replace(/`/g, '\\`');

  return `  const result = await $\`${parameterized}\`.text();
  console.log(result);`;
}

function generateParameterizedReadStep(step: ProceduralStep): string {
  const filePath = step.parameters.file_path as string || '';
  const fileName = filePath.split('/').pop() || 'file';

  return `  const filePath = \`\${targetDir}/${fileName}\`;
  const content = await Bun.file(filePath).text();
  console.log(\`Read \${content.length} bytes from \${filePath}\`);
  return content;`;
}

function generateParameterizedWriteStep(step: ProceduralStep): string {
  const filePath = step.parameters.file_path as string || '';
  const fileName = filePath.split('/').pop() || 'file';

  return `  const filePath = \`\${targetDir}/${fileName}\`;
  const content = ""; // TODO: Set content
  await Bun.write(filePath, content);
  console.log(\`Wrote to \${filePath}\`);`;
}

function generateParameterizedEditStep(step: ProceduralStep): string {
  const filePath = step.parameters.file_path as string || '';
  const fileName = filePath.split('/').pop() || 'file';

  return `  const filePath = \`\${targetDir}/${fileName}\`;
  let content = await Bun.file(filePath).text();
  // TODO: Apply edit transformation
  await Bun.write(filePath, content);
  console.log(\`Edited \${filePath}\`);`;
}

function generateParameterizedGlobStep(step: ProceduralStep): string {
  const pattern = step.parameters.pattern as string || '**/*';

  return `  const glob = new Bun.Glob(${JSON.stringify(pattern)});
  const files = Array.from(glob.scanSync(targetDir));
  console.log(\`Found \${files.length} files matching ${pattern}\`);
  return files;`;
}

function generateParameterizedGrepStep(step: ProceduralStep): string {
  const pattern = step.parameters.search_pattern as string || 'TODO';

  return `  const result = await $\`grep -r ${JSON.stringify(pattern)} \${targetDir}\`.text().catch(() => "");
  console.log(result || "No matches found");
  return result;`;
}

/**
 * Generate a parameterized replay script from raw memory sequence
 */
export function generateReplayScript(
  name: string,
  memories: Array<{
    toolName: string;
    toolInput: Record<string, unknown>;
  }>,
  description?: string
): string {
  // Extract base path from file operations
  const filePaths = memories
    .filter(m => m.toolInput.file_path)
    .map(m => m.toolInput.file_path as string);

  const basePath = extractBasePath(filePaths);

  const lines: string[] = [
    '#!/usr/bin/env bun',
    '/**',
    ` * ${name}`,
    ` * ${description || 'Auto-generated replay script'}`,
    ' *',
    ' * Usage:',
    ` *   bun .claude/skills/${name}/script.ts [target-directory]`,
    ' */',
    '',
    'import { $ } from "bun";',
    '',
    '// Target directory (defaults to current)',
    'const targetDir = process.argv[2] || process.cwd();',
    '',
    'async function main() {',
    `  console.log("Running: ${name}");`,
    '  console.log(`Target: ${targetDir}`);',
    '  console.log("");',
    '',
  ];

  for (let i = 0; i < memories.length; i++) {
    const mem = memories[i];
    if (!mem) continue;

    const stepNum = i + 1;
    lines.push(`  // Step ${stepNum}: ${mem.toolName}`);

    switch (mem.toolName) {
      case 'Bash':
        const cmd = mem.toolInput.command as string || '';
        // Parameterize paths in command
        const paramCmd = basePath
          ? cmd.replace(new RegExp(escapeRegex(basePath), 'g'), '${targetDir}')
          : cmd;
        const escaped = paramCmd.replace(/`/g, '\\`');
        lines.push(`  console.log("$ ${escaped.substring(0, 60).replace(/"/g, '\\"')}${escaped.length > 60 ? '...' : ''}");`);
        lines.push(`  await $\`${escaped}\`;`);
        break;

      case 'Read':
        const readPath = mem.toolInput.file_path as string || '';
        const readFile = readPath.split('/').pop() || 'file';
        const readRelative = basePath ? readPath.replace(basePath + '/', '') : readFile;
        lines.push(`  console.log("Reading: ${readRelative}");`);
        lines.push(`  await Bun.file(\`\${targetDir}/${readRelative}\`).text();`);
        break;

      case 'Write':
        const writePath = mem.toolInput.file_path as string || '';
        const writeFile = writePath.split('/').pop() || 'file';
        lines.push(`  console.log("Writing: ${writeFile}");`);
        lines.push(`  // await Bun.write(\`\${targetDir}/${writeFile}\`, content);`);
        break;

      case 'Edit':
        const editPath = mem.toolInput.file_path as string || '';
        const editFile = editPath.split('/').pop() || 'file';
        const editRelative = basePath ? editPath.replace(basePath + '/', '') : editFile;
        lines.push(`  console.log("Editing: ${editRelative}");`);
        lines.push(`  // Edit \${targetDir}/${editRelative}`);
        break;

      case 'Glob':
        const pattern = mem.toolInput.pattern as string || '**/*';
        lines.push(`  console.log("Finding: ${pattern}");`);
        lines.push(`  const files${stepNum} = Array.from(new Bun.Glob(${JSON.stringify(pattern)}).scanSync(targetDir));`);
        lines.push(`  console.log(\`  Found \${files${stepNum}.length} files\`);`);
        break;

      case 'Grep':
        const searchPattern = mem.toolInput.pattern as string || '';
        lines.push(`  console.log("Searching: ${searchPattern}");`);
        lines.push(`  await $\`grep -r ${JSON.stringify(searchPattern)} \${targetDir}\`.quiet();`);
        break;

      default:
        lines.push(`  // ${mem.toolName}: ${JSON.stringify(mem.toolInput).substring(0, 60)}`);
    }
    lines.push('');
  }

  lines.push('  console.log("Done!");');
  lines.push('}');
  lines.push('');
  lines.push('main().catch(e => { console.error(e); process.exit(1); });');

  return lines.join('\n');
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Describe a tool operation in human-readable form
 */
export function describeToolOperation(
  toolName: string,
  toolInput: Record<string, unknown>
): string {
  switch (toolName) {
    case 'Bash':
      const cmd = (toolInput.command as string || '').split('\n')[0] || '';
      return `Run: \`${cmd.substring(0, 50)}${cmd.length > 50 ? '...' : ''}\``;

    case 'Read':
      const readPath = toolInput.file_path as string || '';
      const readFile = readPath.split('/').pop() || 'file';
      return `Read \`${readFile}\` to understand its contents`;

    case 'Write':
      const writePath = toolInput.file_path as string || '';
      const writeFile = writePath.split('/').pop() || 'file';
      return `Create/update \`${writeFile}\``;

    case 'Edit':
      const editPath = toolInput.file_path as string || '';
      const editFile = editPath.split('/').pop() || 'file';
      return `Modify \`${editFile}\``;

    case 'Glob':
      return `Find files matching \`${toolInput.pattern}\``;

    case 'Grep':
      return `Search for \`${toolInput.pattern}\` in files`;

    case 'WebFetch':
      const url = toolInput.url as string || '';
      try {
        const domain = new URL(url).hostname;
        return `Fetch information from ${domain}`;
      } catch {
        return `Fetch web content`;
      }

    default:
      return `Use ${toolName} tool`;
  }
}
